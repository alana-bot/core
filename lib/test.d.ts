// Generated by dts-bundle v0.7.2
// Dependencies for this module:
//   ../bluebird
//   ../natural

declare module 'test' {
    import { GreetingFunction } from 'test/types/bot';
    export { Intent, Incoming, GreetingFunction } from 'test/types/bot';
    export { User } from 'test/types/user';
    export { PlatformMiddleware } from 'test/types/platform';
    export { MessageTypes } from 'test/types/message';
    import Script from 'test/scripting/script';
    import Alana from 'test/bot';
    export default Alana;
    import TestPlatform from 'test/testing/platform';
    import Tester from 'test/testing/tester';
    export { TestPlatform };
    global  {
        const newScript: (name?: string) => Script;
        const newTest: (userId?: string) => Tester;
        const addGreeting: (greeting: GreetingFunction) => void;
    }
}

declare module 'test/types/bot' {
    import { User } from 'test/types/user';
    import * as Promise from 'bluebird';
    import { IncomingMessage } from 'test/types/message';
    import Outgoing from 'test/outgoing';
    export interface Intent {
        action: string;
        topic: string;
        details: {
            confidence: number;
        } | any;
    }
    export { IncomingMessage };
    export interface InternalMessageDetails {
        _eaten: boolean;
    }
    export interface Incoming {
        user: User;
        message: IncomingMessage & InternalMessageDetails;
        intent: Intent;
    }
    import * as Message from 'test/types/message';
    export { Message };
    export type StopFunction = () => void;
    export type DialogFunction = (incoming: Incoming, response: Outgoing, stop: StopFunction) => Promise<void>;
    export type GreetingFunction = (user: User, response: Outgoing) => Promise<void>;
    export class IntentGenerator {
        getIntents: (message: IncomingMessage, user: User) => Promise<Array<Intent>>;
    }
    export interface SkillFunction {
        (user: User): Promise<User>;
    }
    export interface ReducerFunction {
        (intents: Array<Intent>, user?: User): Promise<Intent>;
    }
    export interface Logger {
        error(message?: any, ...optionalParams: any[]): void;
        info(message?: any, ...optionalParams: any[]): void;
        log(message?: any, ...optionalParams: any[]): void;
        warn(message?: any, ...optionalParams: any[]): void;
    }
}

declare module 'test/types/user' {
    import * as Bot from 'test/types/bot';
    import { PlatformMiddleware } from 'test/types/platform';
    import * as Promise from 'bluebird';
    export interface User extends BasicUser {
        conversation: Array<Bot.IncomingMessage>;
        state: any;
        script: string;
        scriptStage: number;
        scriptArguments: any;
    }
    export interface BasicUser {
        id: string;
        platform: string;
        _platform: PlatformMiddleware;
    }
    export class UserMiddleware {
        getUser: <U extends User>(user: BasicUser) => Promise<U>;
        saveUser: <U extends User>(user: U) => Promise<U>;
    }
}

declare module 'test/types/platform' {
    import * as Promise from 'bluebird';
    import { OutgoingMessage } from 'test/types/message';
    import { User } from 'test/types/user';
    export class PlatformMiddleware {
        start: () => Promise<this>;
        stop: () => Promise<this>;
        send: <U extends User>(user: U, message: OutgoingMessage) => Promise<this>;
    }
}

declare module 'test/types/message' {
    export interface Message {
        type: MessageType;
    }
    export type Text = 'text';
    export type Image = 'image';
    export type Button = 'button';
    export type Greeting = 'greeting';
    export type Postback = 'postback';
    export type Audio = 'audio';
    import { TextMessage } from 'test/types/messages/text';
    import { ImageMessage } from 'test/types/messages/image';
    import { ButtonMessage } from 'test/types/messages/button';
    import { PostbackMessage } from 'test/types/messages/postback';
    import { GreetingMessage } from 'test/types/messages/greeting';
    import { AudioMessage } from 'test/types/messages/audio';
    export type IncomingMessage = TextMessage | PostbackMessage | GreetingMessage | ImageMessage;
    export type MessageType = Text | Image | Button | Greeting | Postback | Audio;
    export type OutgoingMessage = TextMessage | ImageMessage | ButtonMessage | AudioMessage;
    export const MessageTypes: {
        text: Text;
        image: Image;
        button: Button;
        greeting: Greeting;
        postback: Postback;
        audio: Audio;
    };
    export { TextMessage, ButtonMessage, PostbackMessage, ImageMessage, GreetingMessage, AudioMessage };
}

declare module 'test/scripting/script' {
    import * as Promise from 'bluebird';
    import { Incoming, DialogFunction } from 'test/types/bot';
    import { MinimalScriptActions, ExpectInput, IntentAlways, DialogInput, ButtonInput } from 'test/types/script';
    import Outgoing from 'test/outgoing';
    import Botler from 'test/bot';
    export enum StopScriptReasons {
        Called = 0,
        NewScript = 1,
        ExpectCaught = 2,
    }
    export class StopException extends Error {
        reason: StopScriptReasons;
        constructor(reason: StopScriptReasons);
    }
    export enum EndScriptReasons {
        Called = 0,
        Reached = 1,
    }
    export class EndScriptException extends Error {
        reason: EndScriptReasons;
        constructor(reason: EndScriptReasons);
    }
    export class GotoDialogException extends Error {
        dialogName: string;
        constructor(dialogName: string);
    }
    export default class Script implements MinimalScriptActions {
        expect: ExpectInput;
        intent: IntentAlways<this>;
        dialog: DialogInput;
        button: ButtonInput;
        constructor(bot: Botler, scriptName: string);
        readonly length: number;
        run(incoming: Incoming, outgoing: Outgoing, nextScript: () => Promise<void>, step?: number): Promise<void>;
        begin(dialogFunction: DialogFunction): this;
        _dialog(dialogFunction: DialogFunction): this;
        _dialog(name: string, dialogFunction: DialogFunction): this;
    }
    export function stopFunction(reason?: StopScriptReasons): void;
}

declare module 'test/bot' {
    import * as Promise from 'bluebird';
    import { PlatformMiddleware } from 'test/types/platform';
    import { Intent, IncomingMessage, IntentGenerator, ReducerFunction, GreetingFunction, DialogFunction, Logger } from 'test/types/bot';
    import { UserMiddleware, User, BasicUser } from 'test/types/user';
    export { TopicCollection } from 'test/nlp/classifier';
    export { Intent, PlatformMiddleware };
    import Script from 'test/scripting/script';
    export default class Alana {
        debugOn: Boolean;
        userMiddleware: UserMiddleware;
        onErrorScript: DialogFunction;
        constructor(classifierFile?: string);
        addIntent(newIntent: IntentGenerator): this;
        unshiftIntent(newIntent: IntentGenerator): this;
        newScript(name?: string): Script;
        getScript(name?: string): Script;
        readonly scripts: string[];
        addGreeting(script: GreetingFunction): this;
        setReducer(newReducer: ReducerFunction): this;
        setUserMiddlware(middleware: UserMiddleware): this;
        addPlatform(platform: PlatformMiddleware): this;
        addErrorHandler(dialog: DialogFunction): this;
        turnOnDebug(): this;
        setLogger(logger: Logger): this;
        readonly logger: Logger;
        createEmptyIntent(): Intent;
        createEmptyUser(defaults?: any): User;
        start(): void;
        stop(): void;
        processMessage(basicUser: BasicUser, message: IncomingMessage): Promise<void>;
    }
}

declare module 'test/testing/platform' {
    import * as Promise from 'bluebird';
    import { PlatformMiddleware } from 'test/types/platform';
    import { IncomingMessage, Message } from 'test/types/message';
    import { User } from 'test/types/user';
    import Tester from 'test/testing/tester';
    import Botler from 'test/bot';
    export default class TestPlatform implements PlatformMiddleware {
        testers: {
            [key: string]: Tester;
        };
        constructor(bot: Botler);
        start(): Promise<this>;
        stop(): Promise<this>;
        send<U extends User, M extends Message>(user: U, message: M): Promise<this>;
        receive(userId: string, message: IncomingMessage): Promise<void>;
        newTest(userId?: string): Tester;
    }
}

declare module 'test/testing/tester' {
    import * as Promise from 'bluebird';
    import { Message } from 'test/types/message';
    import { Button } from 'test/types/messages/button';
    import TestPlatform from 'test/testing/platform';
    export default class Tester {
            readonly userId: string;
            constructor(platform: TestPlatform, userId?: string);
            /**
                * Wait to recieve a text message from bot
                */
            expectText(allowedPhrases: Array<string> | string): this;
            /**
                * Wait to recieve a set of buttons from bot
                * @todo create a better inirializer to create button object
                * @param text Text for the button message to have
                * @param button Array of raw button strctures
                */
            expectButtons(text: string, button: Array<Button>): this;
            /**
                * During development cam be used to pause the debuger and check input
                */
            debugBreak(): this;
            /**
                * Send a string as the user to the bot
                */
            sendText(text: string): this;
            /**
                *  Send a postback button click as the user to the bot with specififed payload
                */
            sendButtonClick(payload: string): this;
            /**
                * Guard to protect user from forgetting to call run() at end of test
                * @todo automatically call run()
                * @private
                */
            then(...args: any[]): void;
            /**
                * Called to start test
                */
            run(): Promise<any>;
            /**
                * If set to true, will wait for any extra messages not in test script and fail test
                */
            checkForTrailingDialogs(bool?: boolean): this;
            /**
                * Private function to recieve messages from the test platform
                * @private
                */
            receive<M extends Message>(message: M): void;
            /**
                * Private function to recieve errors from test platform
                * @private
                */
            onError(err: Error): void;
    }
}

declare module 'test/outgoing' {
    import { User } from 'test/types/user';
    import * as Messages from 'test/types/message';
    import ButtonClass from 'test/outgoing-class/button';
    import { PlatformMiddleware } from 'test/types/platform';
    import * as Promise from 'bluebird';
    import Botler from 'test/bot';
    export default class Outgoing {
        promise: Promise<PlatformMiddleware>;
        protected user: User;
        protected bot: Botler;
        constructor(bot: Botler, user: User);
        startScript(name?: string, scriptArguments?: any): void;
        endScript(): void;
        goto(dialogName: string): void;
        startTyping(): void;
        endTyping(): void;
        send(...args: any[]): this;
        sendText(text: string): this;
        sendImage(url: string): this;
        sendButtons(): ButtonClass;
        sendButtons(message: Messages.ButtonMessage): this;
        sendAudio(url: string): this;
    }
}

declare module 'test/types/messages/text' {
    import { Message, Text } from 'test/types/message';
    export interface TextMessage extends Message {
        type: Text;
        text: string;
    }
}

declare module 'test/types/messages/image' {
    import { Message, Image } from 'test/types/message';
    export interface ImageMessage extends Message {
        type: Image;
        url: string;
    }
}

declare module 'test/types/messages/button' {
    import { Message, MessageTypes } from 'test/types/message';
    export { MessageTypes };
    export type Button = PostbackButton | LinkButton;
    export type PostbackType = 'postback';
    export type LinkType = 'url';
    export type ButtonType = PostbackType | LinkType;
    export interface PostbackButton {
        type: PostbackType;
        text: string;
        payload: string;
    }
    export interface LinkButton {
        type: LinkType;
        text: string;
        url: string;
    }
    export interface ButtonMessage extends Message {
        type: 'button';
        text: string;
        buttons: Array<Button>;
    }
}

declare module 'test/types/messages/postback' {
    import { Message, Postback } from 'test/types/message';
    export interface PostbackMessage extends Message {
        type: Postback;
        payload: string;
    }
}

declare module 'test/types/messages/greeting' {
    import { Greeting, Message } from 'test/types/message';
    export interface GreetingMessage extends Message {
        type: Greeting;
    }
}

declare module 'test/types/messages/audio' {
    import { Message, Audio } from 'test/types/message';
    export interface AudioMessage extends Message {
        type: Audio;
        url: string;
    }
}

declare module 'test/types/script' {
    import { Incoming, DialogFunction, StopFunction } from 'test/types/bot';
    import Outgoing from 'test/outgoing';
    import Script from 'test/scripting/script';
    import Expect from 'test/scripting/expect';
    export { DialogFunction };
    export type ExpectButton = (dialogFunction: DialogFunction) => Expect;
    export type ExpectButtonWith = (postback: string, dialogFunction: DialogFunction) => Expect;
    export type IntentDomain<returns> = (domian: string, fn: DialogFunction) => returns;
    export type IntentDomainAction<returns> = (domian: string, action: string, fn: DialogFunction) => returns;
    export type IntentInput<returns> = (IntentDomain<returns> | IntentDomainAction<returns>);
    export type IntentAlways<returns> = IntentInput<returns> & dotAlways<(IntentDomain<returns> | IntentDomainAction<returns>)>;
    export type ExpectRaw = (dialogFunction: DialogFunction) => Expect;
    export type ExpectInput = {
        text: (dialogFunction: DialogFunction) => Expect;
        button: ExpectButton | ExpectButtonWith;
        intent: IntentInput<Expect>;
        match: (patten: string | RegExp, dialogFunction: DialogFunction) => Expect;
        catch: (dialogFunction: DialogFunction) => Script;
    };
    export type dotAlways<functions> = {
        always: functions;
    };
    export type DialogInput = (DialogNamed | DialogSimple) & dotAlways<(DialogNamed | DialogSimple)>;
    export type DialogSimple = (fn: DialogFunction) => Script;
    export type DialogNamed = (name: string, fn: DialogFunction) => Script;
    export type ButtonInput = (ButtonSimple | ButtonDeclared) & dotAlways<(ButtonSimple | ButtonDeclared)>;
    export type ButtonSimple = (fn: DialogFunction) => Script;
    export type ButtonDeclared = (payload: string, fn: DialogFunction) => Script;
    export interface MinimalScriptActions {
        dialog: DialogInput;
    }
    export { Incoming, Outgoing, StopFunction };
    export abstract class DialogAction {
        always: boolean;
        blocking: boolean;
        consumesMessage: boolean;
        abstract process(request: Incoming): (DialogFunction | null);
    }
}

declare module 'test/nlp/classifier' {
    import * as natural from 'natural';
    export interface ActionCollection {
        action: string;
        phrases: Array<string>;
    }
    export interface TopicCollection {
        topic: string;
        actions: Array<ActionCollection>;
        location: string;
    }
    export interface ActionClassifier {
        [key: string]: natural.LogisticRegressionClassifier;
    }
    export interface Classifiers {
        [key: string]: ActionClassifier;
    }
    export interface Classification {
        label: string;
        topic: string;
        value: number;
    }
    export type filename = string;
    export function onlyDirectories(name: string): boolean;
    export const classifier: typeof natural.LogisticRegressionClassifier;
    export function LoadSavedClassifiers(filename: string): Classifiers;
    export function GenerateClassifier(topicsToLoad: Array<filename | TopicCollection>, cacheFileName?: string): Classifiers;
    export function GenerateTopicClassifier(topic: TopicCollection, allPhrases: Array<string>): {
        [key: string]: natural.LogisticRegressionClassifier;
    };
    export function checkUsingClassifier(text: string, classifier: any, label: string, topic: string): Classification;
    export function runThroughClassifiers(text: string, classifiers: Classifiers, dump?: Boolean): Classification[];
}

declare module 'test/outgoing-class/button' {
    import Outgoing from 'test/outgoing';
    import { Message, MessageType } from 'test/types/message';
    import { Button, PostbackType, LinkType } from 'test/types/messages/button';
    export default class ButtonClass implements Message {
        constructor(outgoing: Outgoing);
        type: MessageType;
        text(): string;
        text(newText: string): this;
        readonly buttons: Array<Button>;
        addButton(newButton: Button): this;
        addButton(type: PostbackType, text: string, payload: string): this;
        addButton(type: LinkType, text: string, url: string): this;
        send(): Outgoing;
    }
}

declare module 'test/scripting/expect' {
    import { MinimalScriptActions, ExpectInput, DialogInput, DialogAction, Incoming, DialogFunction } from 'test/types/script';
    import Script from 'test/scripting/script';
    export type PublicMembers = ExpectInput & MinimalScriptActions;
    export default class Expect extends DialogAction implements PublicMembers {
        dialog: DialogInput;
        blocking: boolean;
        consumesMessage: boolean;
        constructor(script: Script);
        text(dialogFunction: DialogFunction): this;
        button(dialogFunction: DialogFunction): this;
        button(postback: string, dialogFunction: DialogFunction): this;
        intent(domian: string, fn: DialogFunction): this;
        intent(domian: string, action: string, fn: DialogFunction): this;
        match(pattern: string | RegExp, dialogFunction: DialogFunction): this;
        catch(dialogFunction: DialogFunction): Script;
        process(request: Incoming): DialogFunction;
    }
}

